{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE RecordWildCards            #-}
-- | Tool for starting and stopping subscriptions while app is running.
module Miso.Subscription.Manager (
  SubscriptionManager,
  newSubscriptionManager,
  startSubscription,
  stopSubscription,
  managerSub
  ) where

import Prelude                 hiding (lookup)
import Control.Concurrent      (forkIO)
import Control.Concurrent.Chan (Chan, newChan, writeChan, readChan)
import Control.Concurrent.MVar (MVar, newMVar, newEmptyMVar)
import Control.Concurrent.MVar (modifyMVar, modifyMVar_, readMVar, putMVar)
import Control.Monad           (void, forever)
import Data.IORef              (IORef, newIORef, readIORef, writeIORef)
import Data.IntMap             (IntMap, insert, lookup, delete)
import GHC.Generics            (Generic)

import Miso.Html.Internal      (Sub)

-- | Provides facilities for adding/removing subscriptions.
data SubscriptionManager action model = SubscriptionManager {
  -- | Managed subscriptions. What is stored here is a mutable boolean
  -- which we set to "false" when the subscription is stopped, making
  -- it skip writing generated events to the channel.
  subscriptions :: MVar (IntMap (IORef Bool), Int),
  -- | Channel for subscriptions to write their events to.
  eventsChan :: Chan action,
  -- | Some subscription types need access to the mutable model. Store here.
  ioModel :: MVar (IO model)
  } deriving (Generic)

-- | Create a new subscription manager.
newSubscriptionManager :: IO (SubscriptionManager action model)
newSubscriptionManager = SubscriptionManager <$> newMVar (mempty, 0)
                                             <*> newChan
                                             <*> newEmptyMVar

-- | Add a new subscription to the manager.
--
-- This can be called before 'managerSub' is, but it will block until then.
startSubscription
  :: SubscriptionManager action model -- ^ Manager.
  -> Sub action model -- ^ Subscription function. Non-blocking.
  -> IO Int -- ^ ID of the new subscription.
startSubscription (SubscriptionManager{..}) sub = do
  getModel <- readMVar ioModel
  modifyMVar subscriptions $ \(subs, subId) -> do
    subIsActive <- newIORef True
    sub getModel $ \action -> readIORef subIsActive >>= \case
      True -> writeChan eventsChan action
      False -> pure ()
    pure ((insert subId subIsActive subs, subId + 1), subId)

-- | Stop a subscription, given its ID.
--
-- Note that this only prevents any actions generated by that
-- subscription from entering the channel. It's the responsibility of
-- the user to stop any asynchronous functions/threads/etc that might
-- be producing those events. For example, if your subscription gets
-- events from a WebSocket, you should close that websocket so it's
-- not using CPU/memory/network. If your subscription listens to
-- events from the window, you should remove relevant event listeners.
--
-- Idempotent and safe to call even if the given ID doesn't exist.
stopSubscription :: SubscriptionManager action model -> Int -> IO ()
stopSubscription (SubscriptionManager{..}) subId = do
  modifyMVar_ subscriptions $ \(subs, nextId) -> do
    case lookup subId subs of
      Nothing -> pure (subs, nextId)
      Just ref -> (delete subId subs, nextId) <$ writeIORef ref False

-- | Create a subscription from a subscription manager. Put a call to
-- this into the @subs@ list on your @App@.
managerSub :: SubscriptionManager action model -> Sub action model
managerSub (SubscriptionManager{..}) getModel sink = do
  putMVar ioModel getModel
  void $ forkIO $ forever $ readChan eventsChan >>= sink
